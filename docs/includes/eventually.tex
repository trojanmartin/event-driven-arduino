\subsection{Eventually}
\noindent \par
Eventually je jednoduchá knižnica, ktorej cieľom je zjednodušenie udalosťami riadeného
programovania na platforme Arduino. Zdrojový kód Eventually je open-source a je zapísaný v jazyku C++. Celá knižnica vznikla v roku 2016 a je dostupná pod MIT licenciou.
\par Pre demonštráciu použitia knižnice opíšeme štruktúru programu, ktorý stlačením tlačidla spustí blikanie LED žiarovky. Program napísaný pomocou Eventually môžeme rozdeliť na tri časti.

\par Prvou je definícia makier a globálnych premenných. To vyzerá nasledovne:
\begin{lstlisting}[
    label={lst:main-c},
    language=c
  ]  
  #include <Eventually.h>

  #define LIGHT_PIN 5
  #define BUTTON_PIN 3
  
  EvtManager mgr;
  bool blink_state = LOW;

  USE_EVENTUALLY_LOOP(mgr)
\end{lstlisting}

Ako prvé je nutné prilinkovať knižnicu. Následne definujeme piny, s ktorými budeme pracovať a vytvoríme premennú manažéra udalostí spolu s pomocnou premennou na uloženie aktuálneho stavu LED žiarovky. Poslednou časťou je makro definované v zdrojovom kóde Eventually. To nahrádza štandardnú funkciu loop a je využívané samotnou knižnicou na beh programu.

\par Druhou súčasťou programu je funkcia setup. Je to štandardná funkcia Arduino platformy, ktorá je zavolaná
jedenkrát po štarte. Nachádza sa tu, ako názov funkcie napovedá, kód, ktorého úlohou je
nastavenie základných vlastností aplikácie. Ako prvé nastavíme správny mód pinom, ktoré chceme neskôr používať. Nasleduje použitie už
spomínaného manažéra udalostí. Pomocou funkcie \textit{addListener} vytvoríme nový \textit{EvtPinListener}, ktorý bude počúvať na stlačenie tlačidla.
Keď daná udalosť nastane, zavolá metódu \textit{start\_blinking}, ktorej sa bude venovať neskôr v tejto kapitole.
Takýmto spôsobom je možné zaregistrovať rôznych  „poslucháčov“  na rôzne udalosti. V našom prípade opisovaná funkcia vyzerá nasledovne:

\begin{lstlisting}[
    label={lst:main-c},
    language=c
  ]  
  void setup() {
    /* Set the pin modes */
    pinMode(LIGHT_PIN, OUTPUT);
    pinMode(BUTTON_PIN, INPUT);
  
    /* Add a button listener */
    mgr.addListener(new EvtPinListener(BUTTON_PIN, (EvtAction)start_blinking));

    /* Button is LOW when pushed, so use INPUT_PULLUP */
    pinMode(BUTTON_PIN, INPUT_PULLUP);

    /* Add a button listener, listening for LOW */
    /* (To use this constructor, we also have to specify the debounce delay) */
    mgr.addListener(new EvtPinListener(BUTTON_PIN, 40, LOW, (EvtAction)start_blinking);
  }
\end{lstlisting}

\par Poslednou časťou kódu sú obslužné funkcie udalostí. Ako sme popísali vyššie, po stlačení tlačidla sa zavolá funkcia \textit{start\_blinking}.
Najskôr je potrebné odstrániť všetkých zaregistrovaných poslucháčov na udalosti a následne pridáme dvoch nových. Prvou je časová udalosť.
Táto bude využitá na pravidelné zapnutie a vypnutie LED žiarovky.
V intervale 500 milisekúnd bude pravidelne volaná funkcia \textit{blink\_pin}, ktorá zabezpečí zapnutie, resp. vypnutie žiarovky.
Druhou udalosťou je opätovné stlačenie tlačidla, ktorým je možné zastaviť blikanie žiarovky. Vo funkcii \textit{stop\_blinking} taktiež odstránime aktuálnych poslucháčov a pridáme nového,
ktorý zabezpečí opätovné začatie blikania.

\begin{lstlisting}[
    label={lst:main-c},
    language=c
  ]
bool start_blinking() {
  mgr.resetContext(); 
  mgr.addListener(new EvtTimeListener(500, true, (EvtAction)blink_pin));
  mgr.addListener(new EvtPinListener(BUTTON_PIN, (EvtAction)stop_blinking));
  return true;
}

bool blink_pin() {
  blink_state = !blink_state;
  digitalWrite(LIGHT_PIN, blink_state);
  return false;
}
  
bool stop_blinking() {
  mgr.resetContext();
  mgr.addListener(new EvtPinListener(BUTTON_PIN, (EvtAction)start_blinking));
  return true;
}

\end{lstlisting}

\par V popísanom programe sme využili existujúcich poslucháčov, ktorí sú definovaní v knižnici Eventually.
Pri pokročilom používaní Eventually je možné vytvoriť aj vlastných a to vytvorením novej zdedenej triedy, ktorej základom je \textit{EvtListener} \cite{bartlettEventually2021}.

\par Knižnica Eventually nám umožňuje definovanie obslužných funkcií a funguje ako rozposielač udalostí. Našou úlohou je definícia týchto funkcií, ktoré vykonávajú nami definované akcie.
Pri pokročilejšom použití je taktiež možné definovať aj vlastné udalosti. Vďaka týmto
vlastnostiam je Eventually vhodnou voľbou pre programovanie pomocou udalosťami riadenej
paradigmy. Disponuje však aj nevýhodami, kam sa zaraďuje aj skutočnosť, že nijakým spôsobom nespravuje aktuálny stav programu. Nerozlišuje, kedy udalosť nastala a
celá správa je ponechaná na konečného užívateľa. Taktiež všetky udalosti sú generované softvérovo. To znamená, že Eventually v cykle kontroluje či pre zaregistrovaných poslucháčov nastala udalosť.
Ak áno, zavolá obslužnú funkciu. Týmto spôsobom však môže prísť k značnej latencii medzi časom, kedy udalosť skutočne nastala a vyvolaním obslužnej funkcie.